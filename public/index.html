<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="mixer.css"/>
</head>
<body>
<audio id="mc" controls controlsList="nodownload" style="width: calc(52px * 7); display: block;">
    <source src="/05%20-%20Hash%20Pipe.opus" type="audio/ogg">
</audio>
<ul>
    <li><a href="/05%20-%20Hash%20Pipe.opus" class="switch">05 - Hash Pipe</a></li>
    <li><a href="/09%20-%20Kids.opus" class="switch">09 - Kids</a></li>
</ul>
<div class="mixer">
    <div class="trackstrip">
    </div>
</div>
<template id="trackTemplate">
    <div class="track" data-track="Drums">
        <div class="label">
            <span class="name center">Drums</span>
        </div>
        <div class="button-container">
            <div class="mute-button">
                <label>
                    <input type="checkbox" value="1">
                    <span>M</span>
                </label>
            </div>
            <div class="solo-button">
                <label>
                    <input type="checkbox" value="1">
                    <span>S</span>
                </label>
            </div>
        </div>
        <div class="label">
            <span class="level right">0.00dB</span>
        </div>
        <div class="fader">
            <input type="range" min="0" max="1.0" step="any" value="0.787">
        </div>
    </div>
</template>
<script src="mixer.js"></script>
<script src="track.js"></script>
<script>
    let mixer = new Mixer();

    mixer.addTracks([
        {
            name: "Drums",
            channels: 2
        },
        {
            name: "Bass"
        },
        {
            name: "Gtr MG",
            pan: -0.8
        },
        {
            name: "Gtr JD",
            pan: +0.8
        },
        {
            name: "Vox MG",
            pan: 0
        },
        {
            name: "Vox JD",
            pan: +0.33
        }
    ]);

    const maxGain = 3.0;

    // Math.pow((6.0 * Math.log(g) / Math.log(2.0) + 192.0) / 198.0, 8.0)
    function dB_to_fader(dB) {
        if (dB == -Infinity) return 0.0;
        let gain = Math.pow(10.0, dB / 20.0) * 2.0 / maxGain;
        let fader = Math.pow((6.0 * Math.log(gain) / Math.log(2.0) + 192.0) / 198.0, 8.0);
        return fader;
    }

    const faderCenter = dB_to_fader(0);
    const faderMax = 1.0;

    // Math.exp(((Math.pow(fader, 1.0 / 8.0) * 198.0) - 192.0) / 6.0 * Math.log(2.0))
    function fader_to_dB(fader) {
        if (fader == 0.0) return -Infinity;
        if (Math.abs(fader - faderCenter) < 1e-6) return 0;
        let gain = Math.exp(((Math.pow(fader, 1.0 / 8.0) * 198.0) - 192.0) / 6.0 * Math.log(2.0)) * maxGain / 2.0;
        let dB = 20.0 * Math.log10(gain);
        return dB;
    }

    function faderByTrack(name) {
        return document.querySelector("div.track[data-track="+name+"] input.level[type=range]");
    }

    function trackFromDescendent(el) {
        let trackEl = el.closest("div.track");
        let trackName = trackEl.getAttribute("data-track");
        let track = mixer.track(trackName);
        return track;
    }

    function withExactDigits(value, maxDigits) {
        let s = value.toPrecision(maxDigits);
        if (s == "-Infinity") {
            s = "-inf";
        } else {
            // Only show maxDigits total digits including 0s:
            let digits = 0, n = 0;
            for (let c of s) {
                if (c >= '0' && c <= '9') {
                    digits++;
                    if (digits >= maxDigits) {
                        s = s.slice(0, n+1);
                        break;
                    }
                }
                n++;
            }
        }
        return s;
    }

    function levelFormat(dB) {
        return `${withExactDigits(dB,3)} dB`;
    }

    function faderInputHandler(el, track) {
        let fader = el.value;
        let dB = fader_to_dB(fader);
        track.level = dB;

        // Update level label:
        let trackEl = el.closest("div.track");
        let levelLabel = trackEl.querySelector(".label span.level");
        levelLabel.innerText = levelFormat(track.level)
    }

    function muteInputHandler(el, track) {
        let mute = el.checked;
        track.mute = mute;
    }

    function soloInputHandler(el, track) {
        let solo = el.checked;
        track.solo = solo;
    }

    // add an AudioContext
    let ac = new AudioContext();

    // Find out <audio> element:
    let mcAudio = document.getElementById("mc");

    // Wire up click handlers on links:
    document.querySelectorAll(".switch").forEach(
        el => el.addEventListener("click", e => {
            e.preventDefault();
            let href = e.target.getAttribute("href");
            mcAudio.src = href;
            mcAudio.play();
            return false;
        })
    );

    let mcSource = ac.createMediaElementSource(mcAudio);
    mcSource.channelCountMode = "explicit";
    mcSource.channelInterpretation = "discrete";

    // TODO: would be nice to detect channel count from source.
    let splitter = ac.createChannelSplitter(8);
    try {
        // For older spec implementations:
        splitter.channelCountMode = "max";
    } catch (e) {
        splitter.channelCountMode = "explicit";
    }
    splitter.channelInterpretation = "discrete";
    mcSource.connect(splitter);

    // Create mixer FX chain:
    mixer.createNodes(ac);

    // Stamp template per each track:
    let trackTemplate = document.getElementById("trackTemplate");
    let trackStrip = document.querySelector(".mixer .trackstrip");
    [...mixer.tracks, mixer.master].forEach(track => {
        // Clone template:
        var node = document.importNode(trackTemplate.content, true);

        // Update name label:
        let nameLabel = node.querySelector(".label span.name");
        nameLabel.innerText = track.name;

        // Update level label:
        let levelLabel = node.querySelector(".label span.level");
        levelLabel.innerText = levelFormat(track.level)

        let trackNode = node.querySelector("div.track");
        trackNode.setAttribute("data-track", track.name);

        let fader = trackNode.querySelector(".fader input[type=range]");
        fader.min = 0;
        fader.max = faderMax;
        fader.value = dB_to_fader(track.level);
        fader.addEventListener("dblclick", e => {
            e.target.value = faderCenter;
            faderInputHandler(e.target, trackFromDescendent(e.target));
        });
        fader.addEventListener("input", e => faderInputHandler(e.target, trackFromDescendent(e.target)));

        let mute = trackNode.querySelector(".mute-button input[type=checkbox]");
        mute.checked = track.mute;
        mute.addEventListener("change", e => muteInputHandler(e.target, trackFromDescendent(e.target)));

        let solo = trackNode.querySelector(".solo-button input[type=checkbox]");
        solo.checked = track.solo;
        solo.addEventListener("change", e => soloInputHandler(e.target, trackFromDescendent(e.target)));

        trackStrip.appendChild(node);
    });

    let c = 0;
    for (let track of mixer.tracks) {
        // Create track FX chain:
        track.createNodes(ac);

        // Connect media output to track input:
        let merger = ac.createChannelMerger(2);
        merger.channelCountMode = "explicit";
        merger.channelInterpretation = "discrete";

        if (track.channels == 2) {
            splitter.connect(merger, c++, 0);
            splitter.connect(merger, c++, 1);
        } else {
            splitter.connect(merger, c, 0);
            splitter.connect(merger, c, 1);
            c++;
        }
        merger.connect(track.inputNode);

        // Connect track FX chain to master track's input:
        track.outputNode.connect(mixer.master.inputNode);
    }
    mixer.applySolo();
</script>
</body>
</html>